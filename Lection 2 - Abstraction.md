### Абстракция данных
---
Абстракция — один из принципов ООП в программировании. По своей сути это процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.

Другими словами, применяя абстракцию данных вы можете использовать характеристики и функции какого-то объекта в ходе написания вашего кода без знания непосредственной реализации этого объекта. 

Простая аналогия:
Для того, чтобы водить, ненужно знать, как работает автомобиль (если мы не говорим о профессиональном и задротском вождении). Для рядового пользователя нужно лишь знать, за что нужно дернуть и на что нажать, чтобы понять, как водить авто (наработку навыка в этот момент мы не обсуждаем)
### Пример реализации абстракции данных
---
Возьмем комплексное число (вы их изучите в следующем семестре).
Что такое комплексное число? 
Комплексное число изначально это число, придуманное для решения уравнений второго и выше порядков (квадратных, кубических и прочих), при которых под знаком квадратного корня появлялось отрицательное число (дискриминант < 0)
##### Алгебраический вид комплексного числа:
```math
c = a + b*i

i - мнимая единица
a и b - вещественные числа

а - действительная часть числа
bi - мнимая часть числа
```

По сути любое вещественное число - это комплексное число без мнимой части:
```
r = a + 0i
```
##### Сложение и вычитание комплексных чисел
```
c1 + c2 = (a1 + a2) + (b1 + b2)i

c1 - c2 = (a1 - a2) + (b1 - b2)i
```
##### Умножение комплексных чисел

Умножение комплексных чисел происходит почленно.
```
c1 * c2 = (a1 + b1i) * (a2 + b2i) = a1*a2  + a1*b2i + b1i*a2 + b1*b2*i*i

i*i = -1 (корень отрицательного числа и отрицательного дискриминанта)

с1 * с2 = a1*a2  + a1*b2i + b1i*a2 - 1*b1*b2 = 
= (a1*a2 - b1*b2) + (a1*b2 + b1*a2)i
```
##### Деление комплексных чисел

При делении комплексных чисел вначале частное представляется в виде дроби, затем числитель и знаменатель умножаются на число, сопряженное знаменателю, после чего полученное выражение приводится к алгебраической записи.
```
c1 / c2 = (a1 + b1i) / (a2 + b2i)

Комплексное сопряженое число - комплексное число с обратным знаком у мнимой части
(a2 + b2i) <=> (a2 - b2i)

Действия в знаменателе:

(a2 + b2i)*(a2 - b2i) = a2*a2 - a2*b2i + a2*b2i - b2i*b2i = a2*a2 + b2*b2

Действия в числителе:

(a1 + b1i)*(a2 - b2i) = a1*a2 - a1*b2i + a2*b1i - b1i*b2i = 
= a1*a2 - a1*b2i + a2*b1i + b1*b2 = a1*a2 + b1*b2 + (a2*b1 - a1*b2)i

i*i = -1 (корень отрицательного числа и отрицательного дискриминанта)

Итого:
c1 / c2  = (a1*a2 + b1*b2 + (a2*b1 - a1*b2)i) / a2*a2 + b2*b2
```
### Реализация абстрактного типа КОМПЛЕКСНОЕ ЧИСЛО
---
##### ФУНКЦИЯ-КОСТРУКТОР
***Функция конструктор*** - это специальная **функция**, позволяющая **инициализировать** **начальное** **состояние** создаваемого объекта абстрактного типа. Проще говоря, это **функция**, которая **создаст** вам **объект** желаемого абстрактного типа с **желаемыми значениями его свойств** (для комплексных чисел - со значениями реальной и мнимой части числа).
```Python
# Конструктор - создает объект абстрактного типа!
def complex_constructor(real, imaginary):
    """
    Функция создания объекта комплексного числа
    real: int/float - реальная часть комплексного числа
    imaginary: int/float - мнимая часть комплексного числа
    Функция возвращает dict, симулирующий комплексное число
    """
    return {"real": real, "imaginary": imaginary}
```
##### ФУНКЦИИ-ГЕТТЕРЫ
***Геттер*** или ***Функция чтения*** - это специальная функция, которая позволяет получить данные из объекта абстрактного класса, доступ к которым напрямую ограничен или нежелателен. Проще говоря, **геттеры** позволяют вам вычленить необходимое **свойство** (иначе называемое *полем*) желаемого объекта абстрактного типа и воспользоваться им. Для комплексных чисел мы создали геттеры реальной и мнимой части нашего комплексного числа. 
```Python
# Функция-геттер, позволяющая получать изолировано свойства объектов абстрактных типов
def get_real(complex_number):
    """
    Функция получения реальной части комплексного числа
    """
    return complex_number["real"]


def get_imaginary(complex_number):
    """
    Функция получения реальной части комплексного числа
    """
    return complex_number["imaginary"]
```
##### Сложение
```Python
# Функции арифметических операций
def add_complex(lhs, rhs):
    """
    Функция сложения двух комплексных чисел
    lhs: Complex - LEFT HAND SIDE - располагается слева от мат. операции
    rhs: Complex - RIGHT HAND SIDE - располагается справа от мат. операции
    """
    result_real = get_real(lhs) + get_real(rhs)
    result_imaginary = get_imaginary(lhs) + get_imaginary(rhs)
    
    result_complex = complex_constructor(result_real, result_imaginary)
    return result_complex
```
##### Вычитание
```Python
def sub_complex(lhs, rhs):
    """
    Функция вычитания двух комплексных чисел
    lhs: Complex - LEFT HAND SIDE - располагается слева от мат. операции
    rhs: Complex - RIGHT HAND SIDE - располагается справа от мат. операции
    """
    result_real = get_real(lhs) - get_real(rhs)
    result_imaginary = get_imaginary(lhs) - get_imaginary(rhs)
    
    result_complex = complex_constructor(result_real, result_imaginary)
    return result_complex
```
##### Умножение
```Python
def mul_complex(lhs, rhs):
    """
    Функция умножения двух комплексных чисел
    lhs: Complex - LEFT HAND SIDE - располагается слева от мат. операции
    rhs: Complex - RIGHT HAND SIDE - располагается справа от мат. операции
    """
    real_real = get_real(lhs) * get_real(rhs)
    imag_imag = get_imaginary(lhs) * get_imaginary(rhs) * (-1)
    imag_real = get_imaginary(lhs) * get_real(rhs) 
    real_imag = get_real(lhs) * get_imaginary(rhs)

    result_real = real_real + imag_imag
    result_imaginary = imag_real + real_imag
    
    result_complex = complex_constructor(result_real, result_imaginary)
    return result_complex
```
##### Деление
```Python
def div_complex(dividend, devider):
    """
    Функция деления комплексного числа на комплексное числл
    dividend: Complex - делимое 
    devider: Complex  - делитель
    
    devider_linked - комплексное сопряженное к делителю
    """
    # комплексное сопряжение
    devider_linked = complex_constructor(get_real(devider), -get_imaginary(devider)) 
    
    # получение числителя и знаменателя дроби, возникающей в процессе деления
    # умножения делителя на комплексное сопряжение к делителю
    result_denominator = mul_complex(devider, devider_linked) # вещественное число в результате
    # умножения делимого на комплексное сопряжение к делителю
    result_numerator = mul_complex(dividend, devider_linked) # комплексное число в результате
    
    # учет знаменателя в числителе (деление комплексного числа на вещественное)
    # деление реальной части числителя на общий знаменатель
    result_numerator_real = get_real(result_numerator) / get_real(result_denominator)
    # деление мнимой части числителя на общий знаменатель
    result_numerator_imaginary = get_imaginary(result_numerator) / get_real(result_denominator)

    # получение итогового комплексного числа
    result_complex = complex_constructor(result_numerator_real, result_numerator_imaginary)
    return result_complex
```
##### ВЫВОД ЧИСЛА В АРИФМЕТИЧЕСКОЙ ФОРМЕ
```Python
# Функция вывода комплексного числа
def print_complex(complex_number):
    """
    Функция вывода в консоль комплексного числа
    """
    # Re + Im = a + bi
    if get_imaginary(complex_number) > 0:
        print(f"{get_real(complex_number)} + {get_imaginary(complex_number)}i")
    else:
        print(f"{get_real(complex_number)} - {-get_imaginary(complex_number)}i")
```
##### ФУНКЦИЯ ПРИВЕДЕНИЕ ЧИСЛА К СТРОКЕ
***Функции приведения*** - это специальные функции, которые позволяют вам привести объект одного абстрактного типа к другому. В нашем случае, это функция, которая **превращает** арифметическую форму *комплексного числа* в *строку*.
```Python
def complex_to_str(complex_number):
    """
    Функция превращения алгебраической формы комплексного числа в строку 
    """
    if get_imaginary(complex_number) > 0:
        return f"{get_real(complex_number)} + {get_imaginary(complex_number)}i"
    else:
        return f"{get_real(complex_number)} - {-get_imaginary(complex_number)}i"

```
