### Previously in OOP
---
Мы немного освоились в теме абстракции данных, поняли, что абстракция позволяет нам настраивать невидимые стены между данными, которые мы хотим использовать в нашем коде, объединять данные в более сложные иерархические структуры, такие как **Абстрактные типы** - в примере у нас было **Комплексное** число, в домашке ***Рациональное***.

Нам стало ясно, что по сути *абстракцию* данных мы можем вводить посредством уже имеющихся в нашем распоряжении инструментов языка программирования - **функций**, которые для нас в вопросах абстракции данных работают как магические **черные ящики**, выполняющие определенную операцию над определенными данными и выдающие **конкретный** результат, при этом **скрывая** то, как они этого результата достигли. 

> [!NOTE]
>  Вспоминаем арифметические операции на комплексными числами. Мы эти операции проводили посредством функций `add_complex`, `sub_complex`, `mul_complex`, `div_complex`.
>  При этом несмотря на то, что, например, для умножения комплексных числел друг на друга необходимо почленно перемножать **мнимые** и **действительные** части чисел друг с другом, в нашем случае для перемножения достаточно лишь **вызвать** функцию  `add_complex` и **передать** ей в качестве **аргументов** 2 комплексных числа для того, чтобы не вдаваясь в реализацию функции получить результат - **произведение комплексных чисел**.

Таким образом, самое главное, что мы поняли - это то, что абстракция данных помогает нам создавать такие **инструменты, типы, объекты** в языке программирования, которые возможно будет использовать даже тем, кто не владеет знаниями о том, как эти **интрументы** должны работать и на чем эта работа должна быть основана.
> [!NOTE]
> *По аналогии с реальным миром: нам не нужно знать, как работает дрель внутри, чтобы просверлить с её помощью дырку в стене. Нам нужно лишь знать, как включить дрель и запустить её, нажав на спусковой механизм, а также то, в каких условиях и для каких целей дрель используется (например, сверлит бетон, гранит и дерево, но металл не может и т.д.)*

### ООП и его РЕАЛЬНЫЕ инструменты
---
**ООП** - это создание абстракции данных специализированными инструментами (классами, их методами, полями и прочим)
Если говорить сложнее, то **ООП** - это попытка перенести код в область взаимодействия набора объектов друг с другом. Идеология объектно-ориентированного программирования разрабатывалась, чтобы связать поведение определенного объекта с его классом, так как людям проще воспринимать окружающий мир как объекты, которые поддаются определенной классификации. 

**Класс** по своей сути является ***абстрактным типом*** и от него мало чем отличается. Как и в случае *абстрактного типа*, **класс** реализует какой-то конкретный набор объектов с одинаковыми свойствами и функциями (например, **Комплексные** или **Рациональные числа**), но делает это чуть более запутанно, но если разобраться, то более продуманно, четко и эффективно. 

Отличие *класса* от *абстрактного типа*, который мы реализовывали ранее заключается в том, что класс строиться не только на функциях, но и на специальных синтаксических конструкциях, который заведомо присутствуют в ОБЪЕКТНО-ОРИЕНТИРОВАННЫХ ЯЗЫКА ПРОГРАММИРОВАНИЯ. При этом **свойста** объекта класса начинают называються **атрибутами** или **полями обхекта класса** (это *переменные*), а функции, которые объект класса может исполнять - это **методы класса** (это *функции*).


```Python
def complex_constructor(real, imaginary):
	return {"real": real, "imaginary": imaginary}
```

В примере видим конструктор типа **Комплексное число**. Здесь свойства - это (???). Так вот, эти же свойства в классе будем называть **атрибутами объекта класса** (реализация далее).
### Реализация комплексного числа, как класса
---
#### Класс, колдунья и магический метод конструктор 
Итак, как и в случае с комплексными числами, которые мы реализовывали посредством функций, для создания **объектов** класса комплексное число нам необходим **конструктор**.

Для того, чтобы объявить питончику о том, что вы создаете новый класс необходимо написать вот такой кодик:
```Python
class ComplexNumber:
	pass # ключевое слово для создания заглушки
		 # работает и на функциях 
```
Данные 2 строчки говорят питону, что скоро будет реализован класс `ComplexNumber`. В то же время, ключевое слово `pass` говорит ему, что пока что конкертной реализации у данного класса **нет**, потому создай пока что заглушку. 

Для того, чтобы научить питон **создавать** нам объекты нашего класса (их мы ещё будем называть **экземплярами**) нам необходимо создать **конструктор** нашего класса:
```Python
class ComplexNumber:
	def __init__(self, real, imaginary):
		self.real = real
		self.imaginary = imaginary
```
Итак, тут `__init__` - это не просто функция. Это заранее присутствующий **СПЕЦИАЛЬНЫЙ МАГИЧЕСКИЙ МЕТОД**, который позволяет питончику создавать конкретные **объекты**, принадлежащих к конкретным **классам**. Как и любая функция, данный метод принимает в себя **аргументы**, которые затем станут **свойствами** нашего будующего **объекта** класса `ComplexNumber`. 

Что же такое новый параметр `self`?
`self` - это специальное зарезервированное в питончике слово, которое говорит питончику, что данная функция - это ничто иное, как **метод класса** (то бишь функция конкретно этого класса). У `self` есть и иные принципы использования, но они нам сейчас не нужны.
В нашем примере через `self.real` и `self.imaginary` мы сохраняем в наш **создающийся экземпляр** класса *ComplexNumber* значения *реальной* и *мнимой* части комплексного числа.

Теперь, если мы напишем вот такой код:
```Python
class ComplexNumber:
	def __init__(self, real, imaginary):
		self.real = real
		self.imaginary = imaginary

c1 = ComplexNumber(1, 2)
print(f"Real f{c1.real}")
print(f"Imaginary f{c1.imaginary}")
```
Мы получим вывод двух чисел **1** и **2**, которые уже будут являться частями нашей переменной **c1** типа **ComplexNumber**.
Как видно по коуду - **получить** из любого сложного объекта какого-либо класса его **свойства/поля** можно при помощи оператора `.` и имени того **свойства**, которое вы хотите заполучить `c1.real === 1`

#### Геттеры
Как уже упоменалось ранее, для того, чтобы в процессе **взаимодействия** со **свойствами** того или иного **класса** или **абстрактного типа** не испортить эти свойства или случайно их **не изменить** - используются функции или **методы геттеры**

В классах их можно реализовать следующим образом:
```Python
class ComplexNumber:
	def __init__(self, real, imaginary):
		self.real = real
		self.imaginary = imaginary

	def get_real(self):
		return self.real

	def get_imaginary(self):
		return self.imaginary
```
Проверка:
```Python
c1 = ComplexNumber(1, 2)
print(f"Real f{c1.real} == {c1.get_real()}")
print(f"Imaginary f{c1.imaginary} == {c1.get_imaginary()}")
```
Как можно заметить, для того, чтобы воспользоваться **методами-геттерами** необходимо вновь прибегнуть к оператору `.` -  `c1.get_imaginary()` и `c1.get_real()`.

#### Арифметические выражения и другие методы
Для реализации арифметических операций дополним наш класс методами
##### Сложение
Реализация:
```Python
class ComplexNumber:
	# магический метод конструктор
	def __init__(self, real, imaginary):
		self.real = real
		self.imaginary = imaginary

	...

	def add(self, lhs):
		pass # реализация метода в файлике с классом
```
Проверка:
```Python
с1 = ComplexNumber(1, 2)
с2 = ComplexNumber(2, 3)
c3 = c1.add(c2)
c4 = c2.add(c1)
```
Как можно заметить, после реализации в классе метода сложения двух комплексных чисел воспользоваться данным методом можно что у **объекта с1**, что у **объекта с2**. Для того, чтобы воспользоваться **методом** `add` необходимо вновь прибегнуть к оператору `.` - `c1.add(c2)` или `c2.add(c1)`. 

Но как узнать, являются ли сложения этих чисел одинаковыми по **результату**? 
Нужен метод, который поможет нам выводить **комплексное число** в консоль, как строку.

##### Приведение комплексного числа к строке
Реализация:
```Python
class ComplexNumber:
	# магический метод конструктор
	def __init__(self, real, imaginary):
		self.real = real
		self.imaginary = imaginary

	...

	def __str__(self):
		pass # реализация метода в файлике с классом
```
Магический метод `__str__` - это метод, который показывает питончику, каким образом необходимо **представлять** тот или иной **объект** какого-либо **класса** как строку. В итоге, после применения к **объекту** данного **класса** функции `str()` питон поймет, как превратить данный объект в строку и сделает это:
```Python
c1 = ComplexNumber(1, 2)
str(c1) <-> "1 + 2i"
```

### Принципы ООП
Так какие же принцыпы ООП своей реализацией мы потрогали за сегодня?
#### Абстракция
Абстрагирование — это способ выделить набор наиболее **важных** атрибутов и методов и исключить **неважные**. Соответственно, абстракция — это использование всех **ЗНАЧИМЫХ** характеристик и функций для описания объекта. Важно представить объект минимальным набором полей и методов без ущерба для решаемой задачи. 

Например, при описании класса Ученик нам нет необходимости выдавать ученику функцию "готовить_еду" или "пресс_качат", так как данная функции характеризуют не только студента, но и другие классы людей. Методы же и аттрибуты объекта должны являться чем-то навроде интерфейса для взаимодействия с объектом. 

Интерфейс - совокупность средств, методов и правил взаимодействия (управления, контроля и т. д.) между элементами системы.
#### Инкапсуляция
Каждый объект — независимая структура. Все, что ему нужно для работы, уже есть у него внутри. Если он пользуется какой-то переменной, она будет описана в теле объекта, а не снаружи в коде. Это делает объекты более гибкими. Даже если внешний код перепишут, логика работы не изменится.
Внутреннее устройство одного объекта закрыто от других: извне «видны» только значения атрибутов и результаты выполнения методов.

### Coming up next...
#### Наследование
#### Полиморфизм
